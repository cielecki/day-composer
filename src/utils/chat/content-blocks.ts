import {
	ContentBlock,
	TextBlock,
	ThinkingBlock,
	RedactedThinkingBlock,
	ToolUseBlock,
	ToolResultBlock,
} from "./types";

/**
 * Ensures content is always in ContentBlock[] format
 */
export const ensureContentBlocks = (
	content: string | ContentBlock[] | undefined,
): ContentBlock[] => {
	if (typeof content === "string") {
		return [{ type: "text", text: content }];
	}
	if (Array.isArray(content)) {
		// Filter out any non-ContentBlock items just in case
		return content.filter(
			(item) =>
				typeof item === "object" && item !== null && "type" in item,
		) as ContentBlock[];
	}
	return []; // Return empty array for undefined or other types
};

/**
 * Filters out empty or invalid content blocks
 */
export const filterEmptyContentBlocks = (blocks: ContentBlock[]): ContentBlock[] => {
	return blocks.filter(block => {
		// Filter out text blocks with empty text
		if (block.type === "text") {
			return block.text && block.text.trim().length > 0;
		}
		// Filter out thinking blocks without content
		if (block.type === "thinking") {
			return block.thinking && block.thinking.trim().length > 0;
		}
		// Filter out incomplete tool_use blocks
		if (block.type === "tool_use") {
			return block.id && block.name;
		}
		// Filter out tool_result blocks without content
		if (block.type === "tool_result") {
			return block.tool_use_id && (block.content || block.is_error);
		}
		// Keep other block types by default
		return true;
	});
};

/**
 * Cleans and formats content blocks for API consumption
 */
export const formatContentBlocks = (content: any[]): any[] => {
	const cleanedBlocks = content.map(block => {
		if (block.type === "tool_use") {
			// Clean up properties that Anthropic API doesn't expect
			/* trunk-ignore(eslint/@typescript-eslint/no-unused-vars) */
			const { isProcessing, ...cleanedBlock } = block;
			return cleanedBlock;
		} else if (block.type === "tool_result") {
			// Clean up properties that Anthropic API doesn't expect
			/* trunk-ignore(eslint/@typescript-eslint/no-unused-vars) */
			const { navigation_targets, is_complete, current_label, ...cleanedBlock } = block;
			return cleanedBlock;
		} else if (block.type === "thinking") {
			// Only include thinking blocks that have a signature (were generated by Anthropic)
			// If no signature, filter out the block entirely
			if (!(block as ThinkingBlock).signature) {
				return null; // This will be filtered out below
			}
			/* trunk-ignore(eslint/@typescript-eslint/no-unused-vars) */
			const { reasoningInProgress, ...cleanedBlock } = block;
			return cleanedBlock;
		}
		return block;
	}).filter(block => block !== null); // Remove null blocks (incomplete thinking)
	
	// Filter out empty content blocks before sending to API
	return filterEmptyContentBlocks(cleanedBlocks);
};

/**
 * Extracts text content from content blocks for TTS
 */
export const extractTextForTTS = (contentBlocks: ContentBlock[]): string => {
	return contentBlocks
		.filter((block): block is TextBlock => block.type === "text")
		.map((block) => block.text)
		.join(" ");
};

/**
 * Checks if content blocks contain incomplete tool calls
 */
export const hasIncompleteToolCalls = (contentBlocks: ContentBlock[]): boolean => {
	return contentBlocks.some(block => 
		block.type === "tool_use" && (!block.input || Object.keys(block.input).length === 0)
	);
};

/**
 * Checks if content blocks contain incomplete thinking blocks
 */
export const hasIncompleteThinking = (contentBlocks: ContentBlock[]): boolean => {
	return contentBlocks.some(block => 
		block.type === "thinking" && 
		(!(block as ThinkingBlock).signature || (block as ThinkingBlock).reasoningInProgress)
	);
};

/**
 * Clears reasoning in progress flags from thinking blocks
 */
export const clearThinkingInProgress = (contentBlocks: ContentBlock[]): ContentBlock[] => {
	return contentBlocks.map(block => {
		if (block.type === "thinking" && (block as ThinkingBlock).reasoningInProgress) {
			return {
				...block,
				reasoningInProgress: false
			} as ThinkingBlock;
		}
		return block;
	});
};

/**
 * Filters tool use blocks from content
 */
export const getToolUseBlocks = (contentBlocks: ContentBlock[]): ToolUseBlock[] => {
	return contentBlocks.filter(
		(block): block is ToolUseBlock => block.type === "tool_use"
	);
}; 